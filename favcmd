# favcmd
v ~/dotfiles/favcmd
v ~/dotfiles/config/nvim/snips
v ~/dotfiles/config/nvim/words

# bookmark
open -a 'Google Chrome.app' https://lzone.de/cheat-sheet  ## cheatsheet Redis, MySQL, ElasticSearch...
open -a 'Google Chrome.app' https://docs.github.com/en/actions/creating-actions/creating-a-composite-action ## github workflow composite action
open -a 'Google Chrome.app' https://www.shellcheck.net  ## shell script checker
open -a 'Google Chrome.app' 'https://github.com/search?q=topic%3Acustom-elements+org%3Agithub&type=repositories' ## github의 web component
open -a 'Google Chrome.app' 'railsg.xyz' ## rails command generator

# bash
echo '\033[31mRed!\033[0m'  ## color 30~ KRGY BMCW; 1:bold 5:blink 7:invt
2>&1 | tee -a ~/tmp/tee/stdout-$(date +"%y%m%d_%H%M").log
netstat -vanp tcp | grep LISTEN  ## check open ports
lsof -i -P | grep LISTEN  ## check open ports
ssh-keygen -f ~/.ssh/id_ed25519 -y  ## public key
date +"%Y-%m-%dT%H:%M:%S%z"  ## iso-8610 in BSD

openssl req -new -newkey rsa:4096 -x509 -sha256 -days 365 -nodes -out cert.crt -keyout cert.key

for i in {1..100}; do echo $i; done
tmux send-keys -t $(tmux split-window -d -P -F "#{pane_id}" 'ssh temp0') 'ls' Enter
for i in {0..6}; do tmux send-keys -t $(tmux split-window -d -P -F "#{pane_id}" "ssh temp$i") 'ls' Enter; tmux select-layout tiled; done

rg --color=never -l ${SEARCH} | xargs perl -i -pe 's/${SEARCH}/xxx/g'  ## find all replace
rg --color=never -l ${SEARCH} | while read -r line; do echo $line; done;  ## loop search files
| cut -c-$COLUMNS

systemctl --type=service --state=active
systemctl --type=service --state=running
jounalctl -u $UNIT -n 100 -f

sudo apt install -y libssl-dev libbz2-dev libreadline-dev libffi-dev liblzma-dev libsqlite3-dev  ## python build dependency in ubuntu


# ruby
bundle exec rails
bundle exec sidekiq
bundle exec ruby -Itest ${TEST}
bundle config set --local path .bundle  ## 사용할 .bundle 경로 지정
bundle config set --local path vendor/bundle
bundle config set --local cache_path vendor/bundle/cache
bundle config set --local force_ruby_platform true
bundle config set --local jobs 4
bundle config set --local retry 3
bundle config set --local clean true
bundle config build.pg --with-pg-config=$(brew --prefix libpq)/bin/pg_config
bundle config build.iconv --with-iconv-dir=$(brew --prefix libiconv)
bundle config build.nokogiri --with-iconv-dir=$(brew --prefix libiconv)
gem bump -v pre

ruby -r openssl -e 'puts OpenSSL::OPENSSL_VERSION'
| ruby -rjson -e 'puts JSON[STDIN.read, symbolize_names: true]'  ## input json: '{"a":[...]}'
| ruby -rnokogiri -e 'puts Nokogiri::XML(STDIN.read)'  ## input XML
| ruby -e 'puts STDIN.read.scan(/.{1,2}/).map { _1.to_i(16).chr }.join'  ## hex to string 1
| ruby -e 'puts [STDIN.read].pack("H*")'  ## hex to string 2. (Hex, Char, Short, Long, ascii etc..)
| ruby -e 'puts Time.at(STDIN.read.gsub(/[^\d]/, "").to_i)'  ## epoch, unix time

echo "\nActiveRecord::Base.establish_connection(adapter: 'postgresql', host: 'localhost', port: 5432, username: 'postgres', password: 'postgres', database: 'dev');\nclass User < ApplicationRecord; self.table_name = 'users' end;\nUser.all\n"; bundle exec rails c  ## attach specific database
find test -name '*.rb' -type f -mtime -30m -exec ls -t {} + | head -n 1 1>&2 | xargs bundle exec rails test  ## test recently modified file

# python
python3 -m http.server 8080

# docker
curl host.docker.internal  ## request host in docker image
curl -XGET -s -o /dev/null -w "%{http_code}" "http://example.com"  ## check http status code
docker run --rm -p 4444:4444 seleniarm/standalone-chromium  ## multi arch selenium
docker system df  ## check docker volume size
du -ks /var/lib/docker/containers/* | sort -n | tail  ## check docker containers size by 1KB
docker compose config | yq '.services[]|key'
docker compose ps -q ${SERVICE} | xargs docker inspect --format='{{.LogPath}}' | tail -n1 | xargs tail -f  ## docker logs from file

# terraform
terraform plan -out plan.out | tee plan.std.out
terraform apply plan.out   ## or TF_LOG=DEBUG or TF_LOG=TRACE

# aws
aws eks update-kubeconfig --name ${CLUSTER_NAME} --profile ${PROFILE}
aws configure --profile ${PROFILE} ## region=ap-northeast-2, format=text|table|json|yaml
aws s3 ls
aws sts get-caller-identity --profile ${PROFILE}
aws sts get-caller-identity --query Account --output text  ## get aws account id
aws ecr get-login-password --region ${AWS_REGION} | docker login --password-stdin --username AWS ${ECR_REGISTRY}
aws ecr get-login-password | docker login --password-stdin --username AWS ${AWS_ID}.dkr.ecr.ap-northeast-2.amazonaws.com
curl -H "X-aws-ec2-metadata-token: $(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")" -v "http://169.254.169.254/latest/meta-data/placement/availability-zone-id"  ## IMDSv2 get aws instance az, metadata: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html
curl http://checkip.amazonaws.com/  ## get current ip
aws eks describe-addon-versions --kubernetes-version 1.23 --addon-name coredns --output yaml | grep 'addonVersion:' | head  ## kube-proxy, vpc-cni, coredns, aws-ebs-csi-driver
aws ec2 describe-instances --query 'Reservations[*].Instances[*].[Tags[?Key==`Name`].Value|[0],InstanceId,InstanceType,PrivateIpAddress,PublicIpAddress,State.Name]' --output text
aws ec2 describe-instance-types --query 'InstanceTypes[*].[InstanceType, MemoryInfo.SizeInMiB, VCpuInfo.DefaultVCpus]' --output text | grep -e '^m' | sort -k3 -n


# kubectl
kubectl get pod -A -o custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,IMAGE:.spec.containers[].image'
kubectl get node --sort-by='.metadata.creationTimestamp'
kubectl get nodes -o custom-columns='NAME:.metadata.name,STATUS:.status.conditions[-1:].type,ZONE:.metadata.labels.topology\.kubernetes\.io/zone,NODE_GROUP:.metadata.labels.eks\.amazonaws\.com/nodegroup' | v -
NS=apps envsubst < service.yml | kubectl apply -f -
kubectl auth can-i "*" "*"  ## 권한 체크
docker run -it --rm -v "$HOME/.kube:/.kube" bitnami/kubectl version
export EKS_ENDPOINT=
export EKS_TOKEN=
docker run --rm -e EKS_SERVER=$(aws eks describe-cluster --name $EKS_CLUSTER | jq -r '.cluster.endpoint') -e EKS_TOKEN=$(aws --region ap-northeast-2 eks get-token --cluster-name $EKS_CLUSTER | jq -r '.status.token') bitnami/kubectl --server $EKS_SERVER --token $EKS_TOKEN --insecure-skip-tls-verify version


# helm
helm show values --version ${VER} -n ${NS} ${CHART}
helm get values ${RELEASE_NAME}  ## helm으로 반영된 values.yaml 파일 가져오기
helm ls -a -n ${NS}  ## 특정 네임스페이스의 헬름 차트 인스턴스 목록 띄우기. -A 로 전체 목록

# perl
perl -MIO::Socket::INET -e '$sock=IO::Socket::INET->new(PeerAddr=>"google.com",PeerPort=>"80",Proto=>"tcp"); print $sock "GET / HTTP/1.0\nHost: google.com\n\n"; print while <$sock>'
my $s = new IO::Socket::INET(LocalAddr => "0.0.0.0:8080", Listen => 10, Reuse => 1) or die; while(my $c = $s->accept) { my $body = "Hello World!"; print $c "HTTP/1.1 200 OK\nContent-Type: text/plain\n\n$body\n"; close($c); }
STEP=01 perl -pe '$a=qq{STEP$ENV{STEP}}; /$a:rm/ and $_=qq{}; /$a\s+/ and s/^(\s+)# (.+)\s+## $a[^#\n]+/\1\2/' *.tf

# curl
curl --header "Host: test.example.com" http://aws-domain.elb.amazonaws.com  ## DNS 설정 없이 ingress 테스트할 때 사용
curl --proxy "http://proxy.example.com" "http://example.com"  ## proxy 테스트
curl qrcode.show -d 'test'
| curl qrcode.show -d @-
curl -sS -H "Content-Type: application/json" -d '{ "id": 1, "jsonrpc": "2.0", "method": "rpc_methods", "params": [] }' localhost:9933 | jq ## request JSON-RPC

# git
git log --patch -S ${QUERY}  ## history search
git fetch --tags  ## fetch all tags
git fetch origin tag ${TAG} --no-tags ## fetch single tag
git switch -d tags/${TAG}  ## switch to tag
git worktree add ../${PATH} ${BRANCH}
git push --set-upstream origin master
git status --short | awk '!/##/{print$2}'  ## git status file list
git merge -Xours ${branch}  ## 충돌 발생시, ours (HEAD, stage#2)를 사용한다
git checkout --their -- :g  ## git conflit 해결용, theirs (merge target, stage#3) 기준으로 맞춘다. rebase일 경우 작업물로 설정
git checkout master -- :g  ## git conflit 해결용, master로 맞춰버리기..
git show --name-only
git update-index --chmod=+x $PATH  ## git chmod
git config --global --get user.name
git config --global --get user.email
git config --global --add user.name ${NAME}
git config --global --list

# gh
gh api repos/${OWNER}/${REPO}/pulls/5355  ## list pr info json
gh api repos/${OWNER}/${REPO}/pulls/5355/files  ## list pr files json
gh api repos/${OWNER}/${REPO}/pulls/5355/commits  ## list pr commit json
gh api repos/${{ github.repository }}/pulls/5355 -q '.title'  ## in github action. with `GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}`
gh auth token | clipcopy  ## get github access tokens
gh ssh-key add $KEY_FILE -t $TITLE
gh ssh-key list

gh pr -R $(git remote get-url up | perl -ne 'print /:(.+).git/') list  ## PR list current up remote

# asdf
asdf plugin add terraform
asdf plugin add awscli
asdf plugin add kubectl
asdf plugin add telepresence
asdf plugin add eksctl
asdf plugin add helm
asdf plugin add helmfile
asdf plugin add k9s
asdf plugin add cmctl
asdf plugin add direnv
asdf plugin add yq
asdf plugin add jq
asdf plugin add pre-commit
asdf plugin add nova
asdf plugin add $(curl 'https://github.com/asdf-vm/asdf-plugins/tree/master/plugins' | jq -r '.payload.tree.items[].name' | fzf)
asdf plugin update --all
asdf update

# redis
redis-cli -p 26379 info ## sentinel info
redis-cli -p 26379 sentinel masters ## sentinel masters

# postgres psql
PGPASSWORD='postgres' psql -h localhost -U postgres -c '\l'  ## show databases
PGPASSWORD='postgres' psql -h localhost -U postgres -c 'select * from pg_database;'  ## show databases
PGPASSWORD='postgres' psql -h localhost -U postgres -d $DB -c '\dt'  ## show tables
PGPASSWORD='postgres' psql -h localhost -U postgres -d $DB -c 'select * from pg_catalog.pg_tables'  ## show tables
PGPASSWORD='postgres' psql -h localhost -U postgres -d $DB -c '\d table_name'  ## show table columns
PGPASSWORD='postgres' psql -h localhost -U postgres -d $DB -c 'select * from table_name limit 10'  ## select
PGPASSWORD='postgres' psql -h localhost -U postgres -d $DB -c 'insert into "table_name" ("col1", "col2", ...) '" values ('val1', 'val2', ...)"  ## insert
PGPASSWORD='postgres' psql -h localhost -U postgres -d $DB <<SQL  ## multiline

# open
open -na RubyMine.app --args .
